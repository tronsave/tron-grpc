/**
 * Generated by the protoc-gen-ts.  DO NOT EDIT!
 * compiler version: 5.29.3
 * source: src/proto/contract/shield_contract.proto
 * git: https://github.com/thesayyn/protoc-gen-ts */
import * as pb_1 from "google-protobuf";
export namespace protocol {
    export class AuthenticationPath extends pb_1.Message {
        #one_of_decls: number[][] = [];
        constructor(data?: any[] | {
            value?: boolean[];
        }) {
            super();
            pb_1.Message.initialize(this, Array.isArray(data) ? data : [], 0, -1, [1], this.#one_of_decls);
            if (!Array.isArray(data) && typeof data == "object") {
                if ("value" in data && data.value != undefined) {
                    this.value = data.value;
                }
            }
        }
        get value() {
            return pb_1.Message.getFieldWithDefault(this, 1, []) as boolean[];
        }
        set value(value: boolean[]) {
            pb_1.Message.setField(this, 1, value);
        }
        static fromObject(data: {
            value?: boolean[];
        }): AuthenticationPath {
            const message = new AuthenticationPath({});
            if (data.value != null) {
                message.value = data.value;
            }
            return message;
        }
        toObject() {
            const data: {
                value?: boolean[];
            } = {};
            if (this.value != null) {
                data.value = this.value;
            }
            return data;
        }
        serialize(): Uint8Array;
        serialize(w: pb_1.BinaryWriter): void;
        serialize(w?: pb_1.BinaryWriter): Uint8Array | void {
            const writer = w || new pb_1.BinaryWriter();
            if (this.value.length)
                writer.writePackedBool(1, this.value);
            if (!w)
                return writer.getResultBuffer();
        }
        static deserialize(bytes: Uint8Array | pb_1.BinaryReader): AuthenticationPath {
            const reader = bytes instanceof pb_1.BinaryReader ? bytes : new pb_1.BinaryReader(bytes), message = new AuthenticationPath();
            while (reader.nextField()) {
                if (reader.isEndGroup())
                    break;
                switch (reader.getFieldNumber()) {
                    case 1:
                        message.value = reader.readPackedBool();
                        break;
                    default: reader.skipField();
                }
            }
            return message;
        }
        serializeBinary(): Uint8Array {
            return this.serialize();
        }
        static deserializeBinary(bytes: Uint8Array): AuthenticationPath {
            return AuthenticationPath.deserialize(bytes);
        }
    }
    export class MerklePath extends pb_1.Message {
        #one_of_decls: number[][] = [];
        constructor(data?: any[] | {
            authentication_paths?: AuthenticationPath[];
            index?: boolean[];
            rt?: Uint8Array;
        }) {
            super();
            pb_1.Message.initialize(this, Array.isArray(data) ? data : [], 0, -1, [1, 2], this.#one_of_decls);
            if (!Array.isArray(data) && typeof data == "object") {
                if ("authentication_paths" in data && data.authentication_paths != undefined) {
                    this.authentication_paths = data.authentication_paths;
                }
                if ("index" in data && data.index != undefined) {
                    this.index = data.index;
                }
                if ("rt" in data && data.rt != undefined) {
                    this.rt = data.rt;
                }
            }
        }
        get authentication_paths() {
            return pb_1.Message.getRepeatedWrapperField(this, AuthenticationPath, 1) as AuthenticationPath[];
        }
        set authentication_paths(value: AuthenticationPath[]) {
            pb_1.Message.setRepeatedWrapperField(this, 1, value);
        }
        get index() {
            return pb_1.Message.getFieldWithDefault(this, 2, []) as boolean[];
        }
        set index(value: boolean[]) {
            pb_1.Message.setField(this, 2, value);
        }
        get rt() {
            return pb_1.Message.getFieldWithDefault(this, 3, new Uint8Array(0)) as Uint8Array;
        }
        set rt(value: Uint8Array) {
            pb_1.Message.setField(this, 3, value);
        }
        static fromObject(data: {
            authentication_paths?: ReturnType<typeof AuthenticationPath.prototype.toObject>[];
            index?: boolean[];
            rt?: Uint8Array;
        }): MerklePath {
            const message = new MerklePath({});
            if (data.authentication_paths != null) {
                message.authentication_paths = data.authentication_paths.map(item => AuthenticationPath.fromObject(item));
            }
            if (data.index != null) {
                message.index = data.index;
            }
            if (data.rt != null) {
                message.rt = data.rt;
            }
            return message;
        }
        toObject() {
            const data: {
                authentication_paths?: ReturnType<typeof AuthenticationPath.prototype.toObject>[];
                index?: boolean[];
                rt?: Uint8Array;
            } = {};
            if (this.authentication_paths != null) {
                data.authentication_paths = this.authentication_paths.map((item: AuthenticationPath) => item.toObject());
            }
            if (this.index != null) {
                data.index = this.index;
            }
            if (this.rt != null) {
                data.rt = this.rt;
            }
            return data;
        }
        serialize(): Uint8Array;
        serialize(w: pb_1.BinaryWriter): void;
        serialize(w?: pb_1.BinaryWriter): Uint8Array | void {
            const writer = w || new pb_1.BinaryWriter();
            if (this.authentication_paths.length)
                writer.writeRepeatedMessage(1, this.authentication_paths, (item: AuthenticationPath) => item.serialize(writer));
            if (this.index.length)
                writer.writePackedBool(2, this.index);
            if (this.rt.length)
                writer.writeBytes(3, this.rt);
            if (!w)
                return writer.getResultBuffer();
        }
        static deserialize(bytes: Uint8Array | pb_1.BinaryReader): MerklePath {
            const reader = bytes instanceof pb_1.BinaryReader ? bytes : new pb_1.BinaryReader(bytes), message = new MerklePath();
            while (reader.nextField()) {
                if (reader.isEndGroup())
                    break;
                switch (reader.getFieldNumber()) {
                    case 1:
                        reader.readMessage(message.authentication_paths, () => pb_1.Message.addToRepeatedWrapperField(message, 1, AuthenticationPath.deserialize(reader), AuthenticationPath));
                        break;
                    case 2:
                        message.index = reader.readPackedBool();
                        break;
                    case 3:
                        message.rt = reader.readBytes();
                        break;
                    default: reader.skipField();
                }
            }
            return message;
        }
        serializeBinary(): Uint8Array {
            return this.serialize();
        }
        static deserializeBinary(bytes: Uint8Array): MerklePath {
            return MerklePath.deserialize(bytes);
        }
    }
    export class OutputPoint extends pb_1.Message {
        #one_of_decls: number[][] = [];
        constructor(data?: any[] | {
            hash?: Uint8Array;
            index?: number;
        }) {
            super();
            pb_1.Message.initialize(this, Array.isArray(data) ? data : [], 0, -1, [], this.#one_of_decls);
            if (!Array.isArray(data) && typeof data == "object") {
                if ("hash" in data && data.hash != undefined) {
                    this.hash = data.hash;
                }
                if ("index" in data && data.index != undefined) {
                    this.index = data.index;
                }
            }
        }
        get hash() {
            return pb_1.Message.getFieldWithDefault(this, 1, new Uint8Array(0)) as Uint8Array;
        }
        set hash(value: Uint8Array) {
            pb_1.Message.setField(this, 1, value);
        }
        get index() {
            return pb_1.Message.getFieldWithDefault(this, 2, 0) as number;
        }
        set index(value: number) {
            pb_1.Message.setField(this, 2, value);
        }
        static fromObject(data: {
            hash?: Uint8Array;
            index?: number;
        }): OutputPoint {
            const message = new OutputPoint({});
            if (data.hash != null) {
                message.hash = data.hash;
            }
            if (data.index != null) {
                message.index = data.index;
            }
            return message;
        }
        toObject() {
            const data: {
                hash?: Uint8Array;
                index?: number;
            } = {};
            if (this.hash != null) {
                data.hash = this.hash;
            }
            if (this.index != null) {
                data.index = this.index;
            }
            return data;
        }
        serialize(): Uint8Array;
        serialize(w: pb_1.BinaryWriter): void;
        serialize(w?: pb_1.BinaryWriter): Uint8Array | void {
            const writer = w || new pb_1.BinaryWriter();
            if (this.hash.length)
                writer.writeBytes(1, this.hash);
            if (this.index != 0)
                writer.writeInt32(2, this.index);
            if (!w)
                return writer.getResultBuffer();
        }
        static deserialize(bytes: Uint8Array | pb_1.BinaryReader): OutputPoint {
            const reader = bytes instanceof pb_1.BinaryReader ? bytes : new pb_1.BinaryReader(bytes), message = new OutputPoint();
            while (reader.nextField()) {
                if (reader.isEndGroup())
                    break;
                switch (reader.getFieldNumber()) {
                    case 1:
                        message.hash = reader.readBytes();
                        break;
                    case 2:
                        message.index = reader.readInt32();
                        break;
                    default: reader.skipField();
                }
            }
            return message;
        }
        serializeBinary(): Uint8Array {
            return this.serialize();
        }
        static deserializeBinary(bytes: Uint8Array): OutputPoint {
            return OutputPoint.deserialize(bytes);
        }
    }
    export class OutputPointInfo extends pb_1.Message {
        #one_of_decls: number[][] = [];
        constructor(data?: any[] | {
            out_points?: OutputPoint[];
            block_num?: number;
        }) {
            super();
            pb_1.Message.initialize(this, Array.isArray(data) ? data : [], 0, -1, [1], this.#one_of_decls);
            if (!Array.isArray(data) && typeof data == "object") {
                if ("out_points" in data && data.out_points != undefined) {
                    this.out_points = data.out_points;
                }
                if ("block_num" in data && data.block_num != undefined) {
                    this.block_num = data.block_num;
                }
            }
        }
        get out_points() {
            return pb_1.Message.getRepeatedWrapperField(this, OutputPoint, 1) as OutputPoint[];
        }
        set out_points(value: OutputPoint[]) {
            pb_1.Message.setRepeatedWrapperField(this, 1, value);
        }
        get block_num() {
            return pb_1.Message.getFieldWithDefault(this, 2, 0) as number;
        }
        set block_num(value: number) {
            pb_1.Message.setField(this, 2, value);
        }
        static fromObject(data: {
            out_points?: ReturnType<typeof OutputPoint.prototype.toObject>[];
            block_num?: number;
        }): OutputPointInfo {
            const message = new OutputPointInfo({});
            if (data.out_points != null) {
                message.out_points = data.out_points.map(item => OutputPoint.fromObject(item));
            }
            if (data.block_num != null) {
                message.block_num = data.block_num;
            }
            return message;
        }
        toObject() {
            const data: {
                out_points?: ReturnType<typeof OutputPoint.prototype.toObject>[];
                block_num?: number;
            } = {};
            if (this.out_points != null) {
                data.out_points = this.out_points.map((item: OutputPoint) => item.toObject());
            }
            if (this.block_num != null) {
                data.block_num = this.block_num;
            }
            return data;
        }
        serialize(): Uint8Array;
        serialize(w: pb_1.BinaryWriter): void;
        serialize(w?: pb_1.BinaryWriter): Uint8Array | void {
            const writer = w || new pb_1.BinaryWriter();
            if (this.out_points.length)
                writer.writeRepeatedMessage(1, this.out_points, (item: OutputPoint) => item.serialize(writer));
            if (this.block_num != 0)
                writer.writeInt32(2, this.block_num);
            if (!w)
                return writer.getResultBuffer();
        }
        static deserialize(bytes: Uint8Array | pb_1.BinaryReader): OutputPointInfo {
            const reader = bytes instanceof pb_1.BinaryReader ? bytes : new pb_1.BinaryReader(bytes), message = new OutputPointInfo();
            while (reader.nextField()) {
                if (reader.isEndGroup())
                    break;
                switch (reader.getFieldNumber()) {
                    case 1:
                        reader.readMessage(message.out_points, () => pb_1.Message.addToRepeatedWrapperField(message, 1, OutputPoint.deserialize(reader), OutputPoint));
                        break;
                    case 2:
                        message.block_num = reader.readInt32();
                        break;
                    default: reader.skipField();
                }
            }
            return message;
        }
        serializeBinary(): Uint8Array {
            return this.serialize();
        }
        static deserializeBinary(bytes: Uint8Array): OutputPointInfo {
            return OutputPointInfo.deserialize(bytes);
        }
    }
    export class PedersenHash extends pb_1.Message {
        #one_of_decls: number[][] = [];
        constructor(data?: any[] | {
            content?: Uint8Array;
        }) {
            super();
            pb_1.Message.initialize(this, Array.isArray(data) ? data : [], 0, -1, [], this.#one_of_decls);
            if (!Array.isArray(data) && typeof data == "object") {
                if ("content" in data && data.content != undefined) {
                    this.content = data.content;
                }
            }
        }
        get content() {
            return pb_1.Message.getFieldWithDefault(this, 1, new Uint8Array(0)) as Uint8Array;
        }
        set content(value: Uint8Array) {
            pb_1.Message.setField(this, 1, value);
        }
        static fromObject(data: {
            content?: Uint8Array;
        }): PedersenHash {
            const message = new PedersenHash({});
            if (data.content != null) {
                message.content = data.content;
            }
            return message;
        }
        toObject() {
            const data: {
                content?: Uint8Array;
            } = {};
            if (this.content != null) {
                data.content = this.content;
            }
            return data;
        }
        serialize(): Uint8Array;
        serialize(w: pb_1.BinaryWriter): void;
        serialize(w?: pb_1.BinaryWriter): Uint8Array | void {
            const writer = w || new pb_1.BinaryWriter();
            if (this.content.length)
                writer.writeBytes(1, this.content);
            if (!w)
                return writer.getResultBuffer();
        }
        static deserialize(bytes: Uint8Array | pb_1.BinaryReader): PedersenHash {
            const reader = bytes instanceof pb_1.BinaryReader ? bytes : new pb_1.BinaryReader(bytes), message = new PedersenHash();
            while (reader.nextField()) {
                if (reader.isEndGroup())
                    break;
                switch (reader.getFieldNumber()) {
                    case 1:
                        message.content = reader.readBytes();
                        break;
                    default: reader.skipField();
                }
            }
            return message;
        }
        serializeBinary(): Uint8Array {
            return this.serialize();
        }
        static deserializeBinary(bytes: Uint8Array): PedersenHash {
            return PedersenHash.deserialize(bytes);
        }
    }
    export class IncrementalMerkleTree extends pb_1.Message {
        #one_of_decls: number[][] = [];
        constructor(data?: any[] | {
            left?: PedersenHash;
            right?: PedersenHash;
            parents?: PedersenHash[];
        }) {
            super();
            pb_1.Message.initialize(this, Array.isArray(data) ? data : [], 0, -1, [3], this.#one_of_decls);
            if (!Array.isArray(data) && typeof data == "object") {
                if ("left" in data && data.left != undefined) {
                    this.left = data.left;
                }
                if ("right" in data && data.right != undefined) {
                    this.right = data.right;
                }
                if ("parents" in data && data.parents != undefined) {
                    this.parents = data.parents;
                }
            }
        }
        get left() {
            return pb_1.Message.getWrapperField(this, PedersenHash, 1) as PedersenHash;
        }
        set left(value: PedersenHash) {
            pb_1.Message.setWrapperField(this, 1, value);
        }
        get has_left() {
            return pb_1.Message.getField(this, 1) != null;
        }
        get right() {
            return pb_1.Message.getWrapperField(this, PedersenHash, 2) as PedersenHash;
        }
        set right(value: PedersenHash) {
            pb_1.Message.setWrapperField(this, 2, value);
        }
        get has_right() {
            return pb_1.Message.getField(this, 2) != null;
        }
        get parents() {
            return pb_1.Message.getRepeatedWrapperField(this, PedersenHash, 3) as PedersenHash[];
        }
        set parents(value: PedersenHash[]) {
            pb_1.Message.setRepeatedWrapperField(this, 3, value);
        }
        static fromObject(data: {
            left?: ReturnType<typeof PedersenHash.prototype.toObject>;
            right?: ReturnType<typeof PedersenHash.prototype.toObject>;
            parents?: ReturnType<typeof PedersenHash.prototype.toObject>[];
        }): IncrementalMerkleTree {
            const message = new IncrementalMerkleTree({});
            if (data.left != null) {
                message.left = PedersenHash.fromObject(data.left);
            }
            if (data.right != null) {
                message.right = PedersenHash.fromObject(data.right);
            }
            if (data.parents != null) {
                message.parents = data.parents.map(item => PedersenHash.fromObject(item));
            }
            return message;
        }
        toObject() {
            const data: {
                left?: ReturnType<typeof PedersenHash.prototype.toObject>;
                right?: ReturnType<typeof PedersenHash.prototype.toObject>;
                parents?: ReturnType<typeof PedersenHash.prototype.toObject>[];
            } = {};
            if (this.left != null) {
                data.left = this.left.toObject();
            }
            if (this.right != null) {
                data.right = this.right.toObject();
            }
            if (this.parents != null) {
                data.parents = this.parents.map((item: PedersenHash) => item.toObject());
            }
            return data;
        }
        serialize(): Uint8Array;
        serialize(w: pb_1.BinaryWriter): void;
        serialize(w?: pb_1.BinaryWriter): Uint8Array | void {
            const writer = w || new pb_1.BinaryWriter();
            if (this.has_left)
                writer.writeMessage(1, this.left, () => this.left.serialize(writer));
            if (this.has_right)
                writer.writeMessage(2, this.right, () => this.right.serialize(writer));
            if (this.parents.length)
                writer.writeRepeatedMessage(3, this.parents, (item: PedersenHash) => item.serialize(writer));
            if (!w)
                return writer.getResultBuffer();
        }
        static deserialize(bytes: Uint8Array | pb_1.BinaryReader): IncrementalMerkleTree {
            const reader = bytes instanceof pb_1.BinaryReader ? bytes : new pb_1.BinaryReader(bytes), message = new IncrementalMerkleTree();
            while (reader.nextField()) {
                if (reader.isEndGroup())
                    break;
                switch (reader.getFieldNumber()) {
                    case 1:
                        reader.readMessage(message.left, () => message.left = PedersenHash.deserialize(reader));
                        break;
                    case 2:
                        reader.readMessage(message.right, () => message.right = PedersenHash.deserialize(reader));
                        break;
                    case 3:
                        reader.readMessage(message.parents, () => pb_1.Message.addToRepeatedWrapperField(message, 3, PedersenHash.deserialize(reader), PedersenHash));
                        break;
                    default: reader.skipField();
                }
            }
            return message;
        }
        serializeBinary(): Uint8Array {
            return this.serialize();
        }
        static deserializeBinary(bytes: Uint8Array): IncrementalMerkleTree {
            return IncrementalMerkleTree.deserialize(bytes);
        }
    }
    export class IncrementalMerkleVoucher extends pb_1.Message {
        #one_of_decls: number[][] = [];
        constructor(data?: any[] | {
            tree?: IncrementalMerkleTree;
            filled?: PedersenHash[];
            cursor?: IncrementalMerkleTree;
            cursor_depth?: number;
            rt?: Uint8Array;
            output_point?: OutputPoint;
        }) {
            super();
            pb_1.Message.initialize(this, Array.isArray(data) ? data : [], 0, -1, [2], this.#one_of_decls);
            if (!Array.isArray(data) && typeof data == "object") {
                if ("tree" in data && data.tree != undefined) {
                    this.tree = data.tree;
                }
                if ("filled" in data && data.filled != undefined) {
                    this.filled = data.filled;
                }
                if ("cursor" in data && data.cursor != undefined) {
                    this.cursor = data.cursor;
                }
                if ("cursor_depth" in data && data.cursor_depth != undefined) {
                    this.cursor_depth = data.cursor_depth;
                }
                if ("rt" in data && data.rt != undefined) {
                    this.rt = data.rt;
                }
                if ("output_point" in data && data.output_point != undefined) {
                    this.output_point = data.output_point;
                }
            }
        }
        get tree() {
            return pb_1.Message.getWrapperField(this, IncrementalMerkleTree, 1) as IncrementalMerkleTree;
        }
        set tree(value: IncrementalMerkleTree) {
            pb_1.Message.setWrapperField(this, 1, value);
        }
        get has_tree() {
            return pb_1.Message.getField(this, 1) != null;
        }
        get filled() {
            return pb_1.Message.getRepeatedWrapperField(this, PedersenHash, 2) as PedersenHash[];
        }
        set filled(value: PedersenHash[]) {
            pb_1.Message.setRepeatedWrapperField(this, 2, value);
        }
        get cursor() {
            return pb_1.Message.getWrapperField(this, IncrementalMerkleTree, 3) as IncrementalMerkleTree;
        }
        set cursor(value: IncrementalMerkleTree) {
            pb_1.Message.setWrapperField(this, 3, value);
        }
        get has_cursor() {
            return pb_1.Message.getField(this, 3) != null;
        }
        get cursor_depth() {
            return pb_1.Message.getFieldWithDefault(this, 4, 0) as number;
        }
        set cursor_depth(value: number) {
            pb_1.Message.setField(this, 4, value);
        }
        get rt() {
            return pb_1.Message.getFieldWithDefault(this, 5, new Uint8Array(0)) as Uint8Array;
        }
        set rt(value: Uint8Array) {
            pb_1.Message.setField(this, 5, value);
        }
        get output_point() {
            return pb_1.Message.getWrapperField(this, OutputPoint, 10) as OutputPoint;
        }
        set output_point(value: OutputPoint) {
            pb_1.Message.setWrapperField(this, 10, value);
        }
        get has_output_point() {
            return pb_1.Message.getField(this, 10) != null;
        }
        static fromObject(data: {
            tree?: ReturnType<typeof IncrementalMerkleTree.prototype.toObject>;
            filled?: ReturnType<typeof PedersenHash.prototype.toObject>[];
            cursor?: ReturnType<typeof IncrementalMerkleTree.prototype.toObject>;
            cursor_depth?: number;
            rt?: Uint8Array;
            output_point?: ReturnType<typeof OutputPoint.prototype.toObject>;
        }): IncrementalMerkleVoucher {
            const message = new IncrementalMerkleVoucher({});
            if (data.tree != null) {
                message.tree = IncrementalMerkleTree.fromObject(data.tree);
            }
            if (data.filled != null) {
                message.filled = data.filled.map(item => PedersenHash.fromObject(item));
            }
            if (data.cursor != null) {
                message.cursor = IncrementalMerkleTree.fromObject(data.cursor);
            }
            if (data.cursor_depth != null) {
                message.cursor_depth = data.cursor_depth;
            }
            if (data.rt != null) {
                message.rt = data.rt;
            }
            if (data.output_point != null) {
                message.output_point = OutputPoint.fromObject(data.output_point);
            }
            return message;
        }
        toObject() {
            const data: {
                tree?: ReturnType<typeof IncrementalMerkleTree.prototype.toObject>;
                filled?: ReturnType<typeof PedersenHash.prototype.toObject>[];
                cursor?: ReturnType<typeof IncrementalMerkleTree.prototype.toObject>;
                cursor_depth?: number;
                rt?: Uint8Array;
                output_point?: ReturnType<typeof OutputPoint.prototype.toObject>;
            } = {};
            if (this.tree != null) {
                data.tree = this.tree.toObject();
            }
            if (this.filled != null) {
                data.filled = this.filled.map((item: PedersenHash) => item.toObject());
            }
            if (this.cursor != null) {
                data.cursor = this.cursor.toObject();
            }
            if (this.cursor_depth != null) {
                data.cursor_depth = this.cursor_depth;
            }
            if (this.rt != null) {
                data.rt = this.rt;
            }
            if (this.output_point != null) {
                data.output_point = this.output_point.toObject();
            }
            return data;
        }
        serialize(): Uint8Array;
        serialize(w: pb_1.BinaryWriter): void;
        serialize(w?: pb_1.BinaryWriter): Uint8Array | void {
            const writer = w || new pb_1.BinaryWriter();
            if (this.has_tree)
                writer.writeMessage(1, this.tree, () => this.tree.serialize(writer));
            if (this.filled.length)
                writer.writeRepeatedMessage(2, this.filled, (item: PedersenHash) => item.serialize(writer));
            if (this.has_cursor)
                writer.writeMessage(3, this.cursor, () => this.cursor.serialize(writer));
            if (this.cursor_depth != 0)
                writer.writeInt64(4, this.cursor_depth);
            if (this.rt.length)
                writer.writeBytes(5, this.rt);
            if (this.has_output_point)
                writer.writeMessage(10, this.output_point, () => this.output_point.serialize(writer));
            if (!w)
                return writer.getResultBuffer();
        }
        static deserialize(bytes: Uint8Array | pb_1.BinaryReader): IncrementalMerkleVoucher {
            const reader = bytes instanceof pb_1.BinaryReader ? bytes : new pb_1.BinaryReader(bytes), message = new IncrementalMerkleVoucher();
            while (reader.nextField()) {
                if (reader.isEndGroup())
                    break;
                switch (reader.getFieldNumber()) {
                    case 1:
                        reader.readMessage(message.tree, () => message.tree = IncrementalMerkleTree.deserialize(reader));
                        break;
                    case 2:
                        reader.readMessage(message.filled, () => pb_1.Message.addToRepeatedWrapperField(message, 2, PedersenHash.deserialize(reader), PedersenHash));
                        break;
                    case 3:
                        reader.readMessage(message.cursor, () => message.cursor = IncrementalMerkleTree.deserialize(reader));
                        break;
                    case 4:
                        message.cursor_depth = reader.readInt64();
                        break;
                    case 5:
                        message.rt = reader.readBytes();
                        break;
                    case 10:
                        reader.readMessage(message.output_point, () => message.output_point = OutputPoint.deserialize(reader));
                        break;
                    default: reader.skipField();
                }
            }
            return message;
        }
        serializeBinary(): Uint8Array {
            return this.serialize();
        }
        static deserializeBinary(bytes: Uint8Array): IncrementalMerkleVoucher {
            return IncrementalMerkleVoucher.deserialize(bytes);
        }
    }
    export class IncrementalMerkleVoucherInfo extends pb_1.Message {
        #one_of_decls: number[][] = [];
        constructor(data?: any[] | {
            vouchers?: IncrementalMerkleVoucher[];
            paths?: Uint8Array[];
        }) {
            super();
            pb_1.Message.initialize(this, Array.isArray(data) ? data : [], 0, -1, [1, 2], this.#one_of_decls);
            if (!Array.isArray(data) && typeof data == "object") {
                if ("vouchers" in data && data.vouchers != undefined) {
                    this.vouchers = data.vouchers;
                }
                if ("paths" in data && data.paths != undefined) {
                    this.paths = data.paths;
                }
            }
        }
        get vouchers() {
            return pb_1.Message.getRepeatedWrapperField(this, IncrementalMerkleVoucher, 1) as IncrementalMerkleVoucher[];
        }
        set vouchers(value: IncrementalMerkleVoucher[]) {
            pb_1.Message.setRepeatedWrapperField(this, 1, value);
        }
        get paths() {
            return pb_1.Message.getFieldWithDefault(this, 2, []) as Uint8Array[];
        }
        set paths(value: Uint8Array[]) {
            pb_1.Message.setField(this, 2, value);
        }
        static fromObject(data: {
            vouchers?: ReturnType<typeof IncrementalMerkleVoucher.prototype.toObject>[];
            paths?: Uint8Array[];
        }): IncrementalMerkleVoucherInfo {
            const message = new IncrementalMerkleVoucherInfo({});
            if (data.vouchers != null) {
                message.vouchers = data.vouchers.map(item => IncrementalMerkleVoucher.fromObject(item));
            }
            if (data.paths != null) {
                message.paths = data.paths;
            }
            return message;
        }
        toObject() {
            const data: {
                vouchers?: ReturnType<typeof IncrementalMerkleVoucher.prototype.toObject>[];
                paths?: Uint8Array[];
            } = {};
            if (this.vouchers != null) {
                data.vouchers = this.vouchers.map((item: IncrementalMerkleVoucher) => item.toObject());
            }
            if (this.paths != null) {
                data.paths = this.paths;
            }
            return data;
        }
        serialize(): Uint8Array;
        serialize(w: pb_1.BinaryWriter): void;
        serialize(w?: pb_1.BinaryWriter): Uint8Array | void {
            const writer = w || new pb_1.BinaryWriter();
            if (this.vouchers.length)
                writer.writeRepeatedMessage(1, this.vouchers, (item: IncrementalMerkleVoucher) => item.serialize(writer));
            if (this.paths.length)
                writer.writeRepeatedBytes(2, this.paths);
            if (!w)
                return writer.getResultBuffer();
        }
        static deserialize(bytes: Uint8Array | pb_1.BinaryReader): IncrementalMerkleVoucherInfo {
            const reader = bytes instanceof pb_1.BinaryReader ? bytes : new pb_1.BinaryReader(bytes), message = new IncrementalMerkleVoucherInfo();
            while (reader.nextField()) {
                if (reader.isEndGroup())
                    break;
                switch (reader.getFieldNumber()) {
                    case 1:
                        reader.readMessage(message.vouchers, () => pb_1.Message.addToRepeatedWrapperField(message, 1, IncrementalMerkleVoucher.deserialize(reader), IncrementalMerkleVoucher));
                        break;
                    case 2:
                        pb_1.Message.addToRepeatedField(message, 2, reader.readBytes());
                        break;
                    default: reader.skipField();
                }
            }
            return message;
        }
        serializeBinary(): Uint8Array {
            return this.serialize();
        }
        static deserializeBinary(bytes: Uint8Array): IncrementalMerkleVoucherInfo {
            return IncrementalMerkleVoucherInfo.deserialize(bytes);
        }
    }
    export class SpendDescription extends pb_1.Message {
        #one_of_decls: number[][] = [];
        constructor(data?: any[] | {
            value_commitment?: Uint8Array;
            anchor?: Uint8Array;
            nullifier?: Uint8Array;
            rk?: Uint8Array;
            zkproof?: Uint8Array;
            spend_authority_signature?: Uint8Array;
        }) {
            super();
            pb_1.Message.initialize(this, Array.isArray(data) ? data : [], 0, -1, [], this.#one_of_decls);
            if (!Array.isArray(data) && typeof data == "object") {
                if ("value_commitment" in data && data.value_commitment != undefined) {
                    this.value_commitment = data.value_commitment;
                }
                if ("anchor" in data && data.anchor != undefined) {
                    this.anchor = data.anchor;
                }
                if ("nullifier" in data && data.nullifier != undefined) {
                    this.nullifier = data.nullifier;
                }
                if ("rk" in data && data.rk != undefined) {
                    this.rk = data.rk;
                }
                if ("zkproof" in data && data.zkproof != undefined) {
                    this.zkproof = data.zkproof;
                }
                if ("spend_authority_signature" in data && data.spend_authority_signature != undefined) {
                    this.spend_authority_signature = data.spend_authority_signature;
                }
            }
        }
        get value_commitment() {
            return pb_1.Message.getFieldWithDefault(this, 1, new Uint8Array(0)) as Uint8Array;
        }
        set value_commitment(value: Uint8Array) {
            pb_1.Message.setField(this, 1, value);
        }
        get anchor() {
            return pb_1.Message.getFieldWithDefault(this, 2, new Uint8Array(0)) as Uint8Array;
        }
        set anchor(value: Uint8Array) {
            pb_1.Message.setField(this, 2, value);
        }
        get nullifier() {
            return pb_1.Message.getFieldWithDefault(this, 3, new Uint8Array(0)) as Uint8Array;
        }
        set nullifier(value: Uint8Array) {
            pb_1.Message.setField(this, 3, value);
        }
        get rk() {
            return pb_1.Message.getFieldWithDefault(this, 4, new Uint8Array(0)) as Uint8Array;
        }
        set rk(value: Uint8Array) {
            pb_1.Message.setField(this, 4, value);
        }
        get zkproof() {
            return pb_1.Message.getFieldWithDefault(this, 5, new Uint8Array(0)) as Uint8Array;
        }
        set zkproof(value: Uint8Array) {
            pb_1.Message.setField(this, 5, value);
        }
        get spend_authority_signature() {
            return pb_1.Message.getFieldWithDefault(this, 6, new Uint8Array(0)) as Uint8Array;
        }
        set spend_authority_signature(value: Uint8Array) {
            pb_1.Message.setField(this, 6, value);
        }
        static fromObject(data: {
            value_commitment?: Uint8Array;
            anchor?: Uint8Array;
            nullifier?: Uint8Array;
            rk?: Uint8Array;
            zkproof?: Uint8Array;
            spend_authority_signature?: Uint8Array;
        }): SpendDescription {
            const message = new SpendDescription({});
            if (data.value_commitment != null) {
                message.value_commitment = data.value_commitment;
            }
            if (data.anchor != null) {
                message.anchor = data.anchor;
            }
            if (data.nullifier != null) {
                message.nullifier = data.nullifier;
            }
            if (data.rk != null) {
                message.rk = data.rk;
            }
            if (data.zkproof != null) {
                message.zkproof = data.zkproof;
            }
            if (data.spend_authority_signature != null) {
                message.spend_authority_signature = data.spend_authority_signature;
            }
            return message;
        }
        toObject() {
            const data: {
                value_commitment?: Uint8Array;
                anchor?: Uint8Array;
                nullifier?: Uint8Array;
                rk?: Uint8Array;
                zkproof?: Uint8Array;
                spend_authority_signature?: Uint8Array;
            } = {};
            if (this.value_commitment != null) {
                data.value_commitment = this.value_commitment;
            }
            if (this.anchor != null) {
                data.anchor = this.anchor;
            }
            if (this.nullifier != null) {
                data.nullifier = this.nullifier;
            }
            if (this.rk != null) {
                data.rk = this.rk;
            }
            if (this.zkproof != null) {
                data.zkproof = this.zkproof;
            }
            if (this.spend_authority_signature != null) {
                data.spend_authority_signature = this.spend_authority_signature;
            }
            return data;
        }
        serialize(): Uint8Array;
        serialize(w: pb_1.BinaryWriter): void;
        serialize(w?: pb_1.BinaryWriter): Uint8Array | void {
            const writer = w || new pb_1.BinaryWriter();
            if (this.value_commitment.length)
                writer.writeBytes(1, this.value_commitment);
            if (this.anchor.length)
                writer.writeBytes(2, this.anchor);
            if (this.nullifier.length)
                writer.writeBytes(3, this.nullifier);
            if (this.rk.length)
                writer.writeBytes(4, this.rk);
            if (this.zkproof.length)
                writer.writeBytes(5, this.zkproof);
            if (this.spend_authority_signature.length)
                writer.writeBytes(6, this.spend_authority_signature);
            if (!w)
                return writer.getResultBuffer();
        }
        static deserialize(bytes: Uint8Array | pb_1.BinaryReader): SpendDescription {
            const reader = bytes instanceof pb_1.BinaryReader ? bytes : new pb_1.BinaryReader(bytes), message = new SpendDescription();
            while (reader.nextField()) {
                if (reader.isEndGroup())
                    break;
                switch (reader.getFieldNumber()) {
                    case 1:
                        message.value_commitment = reader.readBytes();
                        break;
                    case 2:
                        message.anchor = reader.readBytes();
                        break;
                    case 3:
                        message.nullifier = reader.readBytes();
                        break;
                    case 4:
                        message.rk = reader.readBytes();
                        break;
                    case 5:
                        message.zkproof = reader.readBytes();
                        break;
                    case 6:
                        message.spend_authority_signature = reader.readBytes();
                        break;
                    default: reader.skipField();
                }
            }
            return message;
        }
        serializeBinary(): Uint8Array {
            return this.serialize();
        }
        static deserializeBinary(bytes: Uint8Array): SpendDescription {
            return SpendDescription.deserialize(bytes);
        }
    }
    export class ReceiveDescription extends pb_1.Message {
        #one_of_decls: number[][] = [];
        constructor(data?: any[] | {
            value_commitment?: Uint8Array;
            note_commitment?: Uint8Array;
            epk?: Uint8Array;
            c_enc?: Uint8Array;
            c_out?: Uint8Array;
            zkproof?: Uint8Array;
        }) {
            super();
            pb_1.Message.initialize(this, Array.isArray(data) ? data : [], 0, -1, [], this.#one_of_decls);
            if (!Array.isArray(data) && typeof data == "object") {
                if ("value_commitment" in data && data.value_commitment != undefined) {
                    this.value_commitment = data.value_commitment;
                }
                if ("note_commitment" in data && data.note_commitment != undefined) {
                    this.note_commitment = data.note_commitment;
                }
                if ("epk" in data && data.epk != undefined) {
                    this.epk = data.epk;
                }
                if ("c_enc" in data && data.c_enc != undefined) {
                    this.c_enc = data.c_enc;
                }
                if ("c_out" in data && data.c_out != undefined) {
                    this.c_out = data.c_out;
                }
                if ("zkproof" in data && data.zkproof != undefined) {
                    this.zkproof = data.zkproof;
                }
            }
        }
        get value_commitment() {
            return pb_1.Message.getFieldWithDefault(this, 1, new Uint8Array(0)) as Uint8Array;
        }
        set value_commitment(value: Uint8Array) {
            pb_1.Message.setField(this, 1, value);
        }
        get note_commitment() {
            return pb_1.Message.getFieldWithDefault(this, 2, new Uint8Array(0)) as Uint8Array;
        }
        set note_commitment(value: Uint8Array) {
            pb_1.Message.setField(this, 2, value);
        }
        get epk() {
            return pb_1.Message.getFieldWithDefault(this, 3, new Uint8Array(0)) as Uint8Array;
        }
        set epk(value: Uint8Array) {
            pb_1.Message.setField(this, 3, value);
        }
        get c_enc() {
            return pb_1.Message.getFieldWithDefault(this, 4, new Uint8Array(0)) as Uint8Array;
        }
        set c_enc(value: Uint8Array) {
            pb_1.Message.setField(this, 4, value);
        }
        get c_out() {
            return pb_1.Message.getFieldWithDefault(this, 5, new Uint8Array(0)) as Uint8Array;
        }
        set c_out(value: Uint8Array) {
            pb_1.Message.setField(this, 5, value);
        }
        get zkproof() {
            return pb_1.Message.getFieldWithDefault(this, 6, new Uint8Array(0)) as Uint8Array;
        }
        set zkproof(value: Uint8Array) {
            pb_1.Message.setField(this, 6, value);
        }
        static fromObject(data: {
            value_commitment?: Uint8Array;
            note_commitment?: Uint8Array;
            epk?: Uint8Array;
            c_enc?: Uint8Array;
            c_out?: Uint8Array;
            zkproof?: Uint8Array;
        }): ReceiveDescription {
            const message = new ReceiveDescription({});
            if (data.value_commitment != null) {
                message.value_commitment = data.value_commitment;
            }
            if (data.note_commitment != null) {
                message.note_commitment = data.note_commitment;
            }
            if (data.epk != null) {
                message.epk = data.epk;
            }
            if (data.c_enc != null) {
                message.c_enc = data.c_enc;
            }
            if (data.c_out != null) {
                message.c_out = data.c_out;
            }
            if (data.zkproof != null) {
                message.zkproof = data.zkproof;
            }
            return message;
        }
        toObject() {
            const data: {
                value_commitment?: Uint8Array;
                note_commitment?: Uint8Array;
                epk?: Uint8Array;
                c_enc?: Uint8Array;
                c_out?: Uint8Array;
                zkproof?: Uint8Array;
            } = {};
            if (this.value_commitment != null) {
                data.value_commitment = this.value_commitment;
            }
            if (this.note_commitment != null) {
                data.note_commitment = this.note_commitment;
            }
            if (this.epk != null) {
                data.epk = this.epk;
            }
            if (this.c_enc != null) {
                data.c_enc = this.c_enc;
            }
            if (this.c_out != null) {
                data.c_out = this.c_out;
            }
            if (this.zkproof != null) {
                data.zkproof = this.zkproof;
            }
            return data;
        }
        serialize(): Uint8Array;
        serialize(w: pb_1.BinaryWriter): void;
        serialize(w?: pb_1.BinaryWriter): Uint8Array | void {
            const writer = w || new pb_1.BinaryWriter();
            if (this.value_commitment.length)
                writer.writeBytes(1, this.value_commitment);
            if (this.note_commitment.length)
                writer.writeBytes(2, this.note_commitment);
            if (this.epk.length)
                writer.writeBytes(3, this.epk);
            if (this.c_enc.length)
                writer.writeBytes(4, this.c_enc);
            if (this.c_out.length)
                writer.writeBytes(5, this.c_out);
            if (this.zkproof.length)
                writer.writeBytes(6, this.zkproof);
            if (!w)
                return writer.getResultBuffer();
        }
        static deserialize(bytes: Uint8Array | pb_1.BinaryReader): ReceiveDescription {
            const reader = bytes instanceof pb_1.BinaryReader ? bytes : new pb_1.BinaryReader(bytes), message = new ReceiveDescription();
            while (reader.nextField()) {
                if (reader.isEndGroup())
                    break;
                switch (reader.getFieldNumber()) {
                    case 1:
                        message.value_commitment = reader.readBytes();
                        break;
                    case 2:
                        message.note_commitment = reader.readBytes();
                        break;
                    case 3:
                        message.epk = reader.readBytes();
                        break;
                    case 4:
                        message.c_enc = reader.readBytes();
                        break;
                    case 5:
                        message.c_out = reader.readBytes();
                        break;
                    case 6:
                        message.zkproof = reader.readBytes();
                        break;
                    default: reader.skipField();
                }
            }
            return message;
        }
        serializeBinary(): Uint8Array {
            return this.serialize();
        }
        static deserializeBinary(bytes: Uint8Array): ReceiveDescription {
            return ReceiveDescription.deserialize(bytes);
        }
    }
    export class ShieldedTransferContract extends pb_1.Message {
        #one_of_decls: number[][] = [];
        constructor(data?: any[] | {
            transparent_from_address?: Uint8Array;
            from_amount?: number;
            spend_description?: SpendDescription[];
            receive_description?: ReceiveDescription[];
            binding_signature?: Uint8Array;
            transparent_to_address?: Uint8Array;
            to_amount?: number;
        }) {
            super();
            pb_1.Message.initialize(this, Array.isArray(data) ? data : [], 0, -1, [3, 4], this.#one_of_decls);
            if (!Array.isArray(data) && typeof data == "object") {
                if ("transparent_from_address" in data && data.transparent_from_address != undefined) {
                    this.transparent_from_address = data.transparent_from_address;
                }
                if ("from_amount" in data && data.from_amount != undefined) {
                    this.from_amount = data.from_amount;
                }
                if ("spend_description" in data && data.spend_description != undefined) {
                    this.spend_description = data.spend_description;
                }
                if ("receive_description" in data && data.receive_description != undefined) {
                    this.receive_description = data.receive_description;
                }
                if ("binding_signature" in data && data.binding_signature != undefined) {
                    this.binding_signature = data.binding_signature;
                }
                if ("transparent_to_address" in data && data.transparent_to_address != undefined) {
                    this.transparent_to_address = data.transparent_to_address;
                }
                if ("to_amount" in data && data.to_amount != undefined) {
                    this.to_amount = data.to_amount;
                }
            }
        }
        get transparent_from_address() {
            return pb_1.Message.getFieldWithDefault(this, 1, new Uint8Array(0)) as Uint8Array;
        }
        set transparent_from_address(value: Uint8Array) {
            pb_1.Message.setField(this, 1, value);
        }
        get from_amount() {
            return pb_1.Message.getFieldWithDefault(this, 2, 0) as number;
        }
        set from_amount(value: number) {
            pb_1.Message.setField(this, 2, value);
        }
        get spend_description() {
            return pb_1.Message.getRepeatedWrapperField(this, SpendDescription, 3) as SpendDescription[];
        }
        set spend_description(value: SpendDescription[]) {
            pb_1.Message.setRepeatedWrapperField(this, 3, value);
        }
        get receive_description() {
            return pb_1.Message.getRepeatedWrapperField(this, ReceiveDescription, 4) as ReceiveDescription[];
        }
        set receive_description(value: ReceiveDescription[]) {
            pb_1.Message.setRepeatedWrapperField(this, 4, value);
        }
        get binding_signature() {
            return pb_1.Message.getFieldWithDefault(this, 5, new Uint8Array(0)) as Uint8Array;
        }
        set binding_signature(value: Uint8Array) {
            pb_1.Message.setField(this, 5, value);
        }
        get transparent_to_address() {
            return pb_1.Message.getFieldWithDefault(this, 6, new Uint8Array(0)) as Uint8Array;
        }
        set transparent_to_address(value: Uint8Array) {
            pb_1.Message.setField(this, 6, value);
        }
        get to_amount() {
            return pb_1.Message.getFieldWithDefault(this, 7, 0) as number;
        }
        set to_amount(value: number) {
            pb_1.Message.setField(this, 7, value);
        }
        static fromObject(data: {
            transparent_from_address?: Uint8Array;
            from_amount?: number;
            spend_description?: ReturnType<typeof SpendDescription.prototype.toObject>[];
            receive_description?: ReturnType<typeof ReceiveDescription.prototype.toObject>[];
            binding_signature?: Uint8Array;
            transparent_to_address?: Uint8Array;
            to_amount?: number;
        }): ShieldedTransferContract {
            const message = new ShieldedTransferContract({});
            if (data.transparent_from_address != null) {
                message.transparent_from_address = data.transparent_from_address;
            }
            if (data.from_amount != null) {
                message.from_amount = data.from_amount;
            }
            if (data.spend_description != null) {
                message.spend_description = data.spend_description.map(item => SpendDescription.fromObject(item));
            }
            if (data.receive_description != null) {
                message.receive_description = data.receive_description.map(item => ReceiveDescription.fromObject(item));
            }
            if (data.binding_signature != null) {
                message.binding_signature = data.binding_signature;
            }
            if (data.transparent_to_address != null) {
                message.transparent_to_address = data.transparent_to_address;
            }
            if (data.to_amount != null) {
                message.to_amount = data.to_amount;
            }
            return message;
        }
        toObject() {
            const data: {
                transparent_from_address?: Uint8Array;
                from_amount?: number;
                spend_description?: ReturnType<typeof SpendDescription.prototype.toObject>[];
                receive_description?: ReturnType<typeof ReceiveDescription.prototype.toObject>[];
                binding_signature?: Uint8Array;
                transparent_to_address?: Uint8Array;
                to_amount?: number;
            } = {};
            if (this.transparent_from_address != null) {
                data.transparent_from_address = this.transparent_from_address;
            }
            if (this.from_amount != null) {
                data.from_amount = this.from_amount;
            }
            if (this.spend_description != null) {
                data.spend_description = this.spend_description.map((item: SpendDescription) => item.toObject());
            }
            if (this.receive_description != null) {
                data.receive_description = this.receive_description.map((item: ReceiveDescription) => item.toObject());
            }
            if (this.binding_signature != null) {
                data.binding_signature = this.binding_signature;
            }
            if (this.transparent_to_address != null) {
                data.transparent_to_address = this.transparent_to_address;
            }
            if (this.to_amount != null) {
                data.to_amount = this.to_amount;
            }
            return data;
        }
        serialize(): Uint8Array;
        serialize(w: pb_1.BinaryWriter): void;
        serialize(w?: pb_1.BinaryWriter): Uint8Array | void {
            const writer = w || new pb_1.BinaryWriter();
            if (this.transparent_from_address.length)
                writer.writeBytes(1, this.transparent_from_address);
            if (this.from_amount != 0)
                writer.writeInt64(2, this.from_amount);
            if (this.spend_description.length)
                writer.writeRepeatedMessage(3, this.spend_description, (item: SpendDescription) => item.serialize(writer));
            if (this.receive_description.length)
                writer.writeRepeatedMessage(4, this.receive_description, (item: ReceiveDescription) => item.serialize(writer));
            if (this.binding_signature.length)
                writer.writeBytes(5, this.binding_signature);
            if (this.transparent_to_address.length)
                writer.writeBytes(6, this.transparent_to_address);
            if (this.to_amount != 0)
                writer.writeInt64(7, this.to_amount);
            if (!w)
                return writer.getResultBuffer();
        }
        static deserialize(bytes: Uint8Array | pb_1.BinaryReader): ShieldedTransferContract {
            const reader = bytes instanceof pb_1.BinaryReader ? bytes : new pb_1.BinaryReader(bytes), message = new ShieldedTransferContract();
            while (reader.nextField()) {
                if (reader.isEndGroup())
                    break;
                switch (reader.getFieldNumber()) {
                    case 1:
                        message.transparent_from_address = reader.readBytes();
                        break;
                    case 2:
                        message.from_amount = reader.readInt64();
                        break;
                    case 3:
                        reader.readMessage(message.spend_description, () => pb_1.Message.addToRepeatedWrapperField(message, 3, SpendDescription.deserialize(reader), SpendDescription));
                        break;
                    case 4:
                        reader.readMessage(message.receive_description, () => pb_1.Message.addToRepeatedWrapperField(message, 4, ReceiveDescription.deserialize(reader), ReceiveDescription));
                        break;
                    case 5:
                        message.binding_signature = reader.readBytes();
                        break;
                    case 6:
                        message.transparent_to_address = reader.readBytes();
                        break;
                    case 7:
                        message.to_amount = reader.readInt64();
                        break;
                    default: reader.skipField();
                }
            }
            return message;
        }
        serializeBinary(): Uint8Array {
            return this.serialize();
        }
        static deserializeBinary(bytes: Uint8Array): ShieldedTransferContract {
            return ShieldedTransferContract.deserialize(bytes);
        }
    }
}
